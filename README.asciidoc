Test case "ramtest"
===================
Christoph Thelen <cthelen@hilscher.com>
:Author Initials: CT
Subhan Waizi <swaizi@hilscher.com>
:Author Initials: SW


[[About, About]]
== About

This document describes the RAM test for the Muhkuh test framework. The RAM test checks SDRAM devices both with random value tests and marching tests. The chapter <<Test_description>> discusses this method in detail.

The RAM test supports all existing netX chips with an SDRAM interface:

[horizontal]
netX500/100:: SDRAM on memory interface (MEM)
netx50:: SDRAM on memory interface (MEM)
netx10:: SDRAM on host interface (HIF)
netx51:: SDRAM on memory interface and host interface (MEM, HIF)
netx52:: SDRAM on host interface (HIF)


[[Test_description,Test description]]
== Test description

The test is divided into two parts. The first part is a pure functional test using marching patterns that detect certain ramspecific faults. Part two consists of a pseudo-random test and can potentially detect all kind of faults but with a given residual error. This residual errors depends on the start values for the random number generation and on the amount of different start values chosen.

.Test Part  I:


- Databus test:
  * If enabled: test checks if each databus line can be set to 0 and 1 without affecting the remaining databus lines by performing a walking one's test. If the test fails it returns the faulty databus line/s. In case of the same databus line being returned as faulty more frequently one could assume problems regarding the circuit board layout.
- Marching C- test:
  * If enabled: test applies specific marching patterns in both ascending and descending orders in order to detect speficic faults like stuck-at faults, stuck-open faults, transition faults and coupling faults with a detection probability of 100%. Test can only detect errors it is looking for.
- Checkerboard test:
  * If enabled: test applies a checkerboard pattern on the memory cells. As the checkerboard pattern is a pattern that triggers maximum current leakage, which could lead to unwanted content changes in a memory cell, this test is used to detect these kind of faults (data retention faults)

If any of the read back values differ from the expected one, the process is stopped and the test case is marked as "failed".



.Test Part II:


The core logic of this part is the random value approach. It fills the memory area with a pseudo random value stream, where "pseudo" means that the numbers are not real random values but computed by a formula.
This means the "random" values are the same for every start of the program. Currently the pseurandom number is generated by a linear feedback leftshift register (LFSR).
This generator guarantees little processing time and a maximum length sequence which repeats after asciimath:[2^number{32} - 1] elements. Once the complete memory area is filled, the values are read back and compared to the expected values.
If a read back value differs from the expected one, the process is stopped and the test case is marked as "failed".

The RAM test applies the random value approach multiple times:

- Repeat this for asciimath:[l] times:
  * Loop over 6 different startvalues for the pseudorandom number generation
  ** If enabled: run the random value test with 8 bit accesses to the memory
  ** If enabled: run the random value test with 16 bit accesses to the memory
  ** If enabled: run the random value test with 32 bit accesses to the memory
  ** If enabled: run the random value test with asciimath:[4*32] bit burst accesses to the memory 

Formula for the maximum length LFSR (ML LFSR): +

*asciimath:[f(n+1)= ( ( ( f(n) ">>" 31 ) text( xor ) ( f(n) ">>" 6 ) text( xor ) ( f(n) ">>" 4) text( xor ) ( f(n) ">>" 1 ) ) text( xor ) f(n) ) \and 1 ) "<<" 31 ) \or ( f(n) ">>" 1 )]* +


The program flow can be modified with a set of parameters:

- +loops+ defines the value for asciimath:[l].
- +checks+ selects the access types to the memory. It enables or disables the databus, marching c-, checkerboard, 8, 16, 32 and burst accesses tests.

The RAM test always starts at the beginning of the SDRAM device. The number of bytes to check from this position on can be configured with the parameter +size_exponent+.
It defines the number of bytes asciimath:[m] as asciimath:[m=2^text{size_exponent}].

[[Parameters, Parameters]]
== Parameters

+general_ctrl+::
  The complete value for the netX +general_ctrl+ register.
+timing_ctrl+::
  The complete value for the netX +timing_ctrl+ register.
+mr+::
  The complete value for the netX +mr+ register.
+size_exponent+::
  Check asciimath:[2^text{size_exponent}] bytes starting from the beginning of the SDRAM device.
+interface+::
  This is the interface where the RAM is connected. It
  must be either +MEM+ for the memory interface or +HIF+ for
  the host interface.
+checks+::
  This determines which checks to run. Select one or more
  values from this list and separate them with
  commata: +DATABUS+, +MARCHC+, +CHECKERBOARD+, +08BIT+, +16BIT+, +32BIT+ and +BURST+.
+loops+::
  The number of loops to run.

[TIP]
A good source for the parameters +general_ctrl+, +timing_ctrl+ and +mr+ is the +netx.xml+ file distributed with the Hilscher Bootwizard (https://kb.hilscher.com/display/BOOTWIZ/netX+Bootwizard).

